{
  "tasks": [
    {
      "metadata": {
        "task_type": "graph_bfs",
        "hardware": {
          "cpus": [
            {
              "cores": 12,
              "threads": 32,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <vector>\n#include <omp.h>\n\nstruct Graph {\n    int numVertices;\n    int numEdges;\n    int* offset;\n    int* edges;\n};\n\nvoid bfs(const Graph& graph, int start, std::vector<int>& result) {\n    result.assign(graph.numVertices, -1);\n    result[start] = 0;\n    \n    std::vector<int> current, next;\n    current.reserve(graph.numVertices);\n    next.reserve(graph.numVertices);\n    current.push_back(start);\n    \n    while (!current.empty()) {\n        std::vector<std::vector<int>> local_nexts(omp_get_max_threads());\n        \n        #pragma omp parallel\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for\n            for (int i = 0; i < static_cast<int>(current.size()); ++i) {\n                int u = current[i];\n                for (int j = graph.offset[u]; j < graph.offset[u+1]; ++j) {\n                    int v = graph.edges[j];\n                    int expected = -1;\n                    if (__sync_val_compare_and_swap(&result[v], expected, result[u]+1) == expected) {\n                        local_nexts[tid].push_back(v);\n                    }\n                }\n            }\n        }\n        \n        next.clear();\n        size_t total = 0;\n        for (auto& vec : local_nexts) total += vec.size();\n        next.reserve(total);\n        for (auto& vec : local_nexts) {\n            next.insert(next.end(), vec.begin(), vec.end());\n        }\n        current.swap(next);\n    }\n}",
        "framework": "OpenMP"
      }
    }
  ]
}