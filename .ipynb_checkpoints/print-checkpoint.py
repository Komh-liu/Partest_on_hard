print("#include <vector>\n#include <atomic>\n#include <omp.h>\n\nvoid bfs(const Graph& graph, int start, std::vector<int>& result) {\n    const int num_vertices = graph.numVertices;\n    result.assign(num_vertices, -1);\n    result[start] = 0;\n\n    std::vector<int> current_level, next_level;\n    current_level.reserve(num_vertices);\n    current_level.push_back(start);\n\n    std::atomic_flag* visited = new std::atomic_flag[num_vertices];\n    for(int i = 0; i < num_vertices; ++i)\n        visited[i].clear();\n    visited[start].test_and_set();\n\n    while(!current_level.empty()) {\n        next_level.clear();\n        std::atomic<int> next_offset(0);\n        next_level.resize(current_level.size() * 2);\n\n        #pragma omp parallel for schedule(dynamic, 64)\n        for(size_t i = 0; i < current_level.size(); ++i) {\n            int u = current_level[i];\n            int degree = graph.offset[u+1] - graph.offset[u];\n            \n            for(int j = 0; j < degree; ++j) {\n                int v = graph.edges[graph.offset[u] + j];\n                if(!visited[v].test_and_set()) {\n                    result[v] = result[u] + 1;\n                    int pos = next_offset.fetch_add(1, std::memory_order_relaxed);\n                    if(pos >= static_cast<int>(next_level.size())) {\n                        #pragma omp critical\n                        {\n                            if(pos >= static_cast<int>(next_level.size()))\n                                next_level.resize(next_level.size() * 2);\n                        }\n                    }\n                    next_level[pos] = v;\n                }\n            }\n        }\n\n        next_level.resize(next_offset.load());\n        current_level.swap(next_level);\n    }\n\n    delete[] visited;\n}")