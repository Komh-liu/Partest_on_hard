{
  "tasks": [
    {
      "metadata": {
        "task_type": "array_sum",
        "hardware": {
          "cpus": [
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <vector>\n#include <omp.h>\n\nusing Array = std::vector<int>;\n\nint array_sum(const Array& arr) {\n    int sum = 0;\n    // MODIFIED: 使用默认线程数，避免硬编码线程数，提高代码的可移植性\n    #pragma omp parallel for reduction(+:sum)\n    for (size_t i = 0; i < arr.size(); ++i) {\n        sum += arr[i];\n    }\n    return sum;\n}",
        "framework": "OpenMP"
      },
      "modification_record": {
        "requirements": "",
        "error_info": ""
      }
    },
    {
      "metadata": {
        "task_type": "matrix_multiply",
        "hardware": {
          "cpus": [
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <vector>\n#include <omp.h>\n\nusing Matrix = std::vector<std::vector<int>>;\n\nvoid matrix_multiply(const Matrix& A, Matrix& result) {\n    int n = A.size();\n    // MODIFIED: 使用动态调度以更好地平衡负载\n    #pragma omp parallel for schedule(dynamic)\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            result[i][j] = 0;\n            // MODIFIED: 使用临时变量减少内存访问次数\n            int temp = 0;\n            for (int k = 0; k < n; ++k) {\n                temp += A[i][k] * A[j][k];\n            }\n            result[i][j] = temp;\n        }\n    }\n}",
        "framework": "OpenMP"
      },
      "modification_record": {
        "requirements": "",
        "error_info": ""
      }
    },
    {
      "metadata": {
        "task_type": "graph_bfs",
        "hardware": {
          "cpus": [
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            },
            {
              "cores": 8,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <vector>\n#include <queue>\n#include <omp.h>\n\nvoid bfs(const Graph& graph, int start, std::vector<int>& result) {\n    // MODIFIED: 使用std::vector<bool>的位压缩特性来减少内存占用\n    std::vector<bool> visited(graph.numVertices, false);\n    std::queue<int> q;\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        result.push_back(current);\n\n        int startEdge = graph.offset[current];\n        int endEdge = (current == graph.numVertices - 1) ? graph.numEdges : graph.offset[current + 1];\n\n        // MODIFIED: 使用OpenMP的task构造来并行处理邻居节点，减少临界区的使用\n        #pragma omp parallel\n        {\n            #pragma omp single\n            {\n                for (int i = startEdge; i < endEdge; ++i) {\n                    #pragma omp task\n                    {\n                        int neighbor = graph.edges[i];\n                        if (!visited[neighbor]) {\n                            #pragma omp critical\n                            {\n                                if (!visited[neighbor]) {\n                                    visited[neighbor] = true;\n                                    q.push(neighbor);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int node : result) {\n        std::cout << node << \" \";\n    }\n    std::cout << std::endl;\n}",
        "framework": "OpenMP"
      },
      "modification_record": {
        "requirements": "内存占用过高，降低内存占用，可以增加CPU的使用",
        "error_info": ""
      }
    }
  ]
}