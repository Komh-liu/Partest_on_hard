{
  "tasks": [
    {
      "metadata": {
        "task_type": "array_sum",
        "hardware": {
          "cpus": [
            {
              "cores": 12,
              "threads": 32,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <tbb/tbb.h>\n#include <tbb/parallel_reduce.h>\n#include <tbb/blocked_range.h>\n#include <vector>\n\nusing Array = std::vector<long long>;\n\nlong long array_sum(const Array& arr) {\n    tbb::global_control gc(tbb::global_control::max_allowed_parallelism, 32);\n    return tbb::parallel_reduce(\n        tbb::blocked_range<size_t>(0, arr.size()),\n        0LL,\n        [&](const tbb::blocked_range<size_t>& r, long long init) {\n            for(size_t i = r.begin(); i < r.end(); ++i)\n                init += arr[i];\n            return init;\n        },\n        std::plus<long long>()\n    );\n}",
        "framework": "TBB"
      }
    },
    {
      "metadata": {
        "task_type": "matrix_multiply",
        "hardware": {
          "cpus": [
            {
              "cores": 12,
              "threads": 32,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <tbb/tbb.h>\n#include <tbb/parallel_for.h>\n#include <tbb/blocked_range.h>\n\nusing Matrix = std::vector<std::vector<int>>;\n\nvoid matrix_multiply(const Matrix& A, Matrix& result) {\n    int n = A.size();\n    if (n == 0) {\n        result.clear();\n        return;\n    }\n    int m = A[0].size();\n    result.resize(n);\n    for (auto& row : result) {\n        row.resize(n);\n    }\n\n    tbb::parallel_for(tbb::blocked_range<int>(0, n),\n        [&](const tbb::blocked_range<int>& range) {\n            for (int i = range.begin(); i != range.end(); ++i) {\n                const auto& rowA = A[i];\n                auto& resRow = result[i];\n                for (int j = 0; j < n; ++j) {\n                    int sum = 0;\n                    const auto& rowB = A[j];\n                    for (int k = 0; k < m; ++k) {\n                        sum += rowA[k] * rowB[k];\n                    }\n                    resRow[j] = sum;\n                }\n            }\n        }\n    );\n}",
        "framework": "TBB"
      }
    },
    {
      "metadata": {
        "task_type": "graph_bfs",
        "hardware": {
          "cpus": [
            {
              "cores": 12,
              "threads": 32,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <tbb/tbb.h>\n#include <tbb/parallel_for.h>\n#include <tbb/enumerable_thread_specific.h>\n#include <tbb/concurrent_vector.h>\n#include <vector>\n#include <atomic>\n#include <memory>\n\nvoid bfs(const Graph& graph, int start, std::vector<int>& result) {\n    const int num_vertices = graph.numVertices;\n    result.resize(num_vertices);\n    std::unique_ptr<std::atomic<int>[]> distances(new std::atomic<int>[num_vertices]);\n\n    tbb::parallel_for(tbb::blocked_range<int>(0, num_vertices), [&](const tbb::blocked_range<int>& r) {\n        for (int i = r.begin(); i < r.end(); ++i)\n            distances[i].store(-1, std::memory_order_relaxed);\n    });\n\n    distances[start].store(0, std::memory_order_relaxed);\n    tbb::concurrent_vector<int> current_frontier;\n    current_frontier.push_back(start);\n\n    while (!current_frontier.empty()) {\n        tbb::enumerable_thread_specific<std::vector<int>> local_next;\n\n        tbb::parallel_for(tbb::blocked_range<size_t>(0, current_frontier.size()), [&](const tbb::blocked_range<size_t>& r) {\n            auto& local = local_next.local();\n            for (size_t i = r.begin(); i < r.end(); ++i) {\n                int u = current_frontier[i];\n                int current_dist = distances[u].load(std::memory_order_relaxed);\n                for (int j = graph.offset[u]; j < graph.offset[u + 1]; ++j) {\n                    int v = graph.edges[j];\n                    int expected = -1;\n                    if (distances[v].compare_exchange_strong(expected, current_dist + 1, std::memory_order_relaxed, std::memory_order_relaxed))\n                        local.push_back(v);\n                }\n            }\n        });\n\n        tbb::concurrent_vector<int> next_frontier;\n        for (const auto& vec : local_next)\n            next_frontier.grow_by(vec.begin(), vec.end());\n        \n        current_frontier.swap(next_frontier);\n    }\n\n    tbb::parallel_for(tbb::blocked_range<int>(0, num_vertices), [&](const tbb::blocked_range<int>& r) {\n        for (int i = r.begin(); i < r.end(); ++i)\n            result[i] = distances[i].load(std::memory_order_relaxed);\n    });\n}",
        "framework": "TBB"
      }
    }
  ]
}