{
  "tasks": [
    {
      "metadata": {
        "task_type": "array_sum",
        "hardware": {
          "cpus": [
            {
              "cores": 20,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <vector>\n#include <omp.h>\n\nusing Array = std::vector<long long>;\n\nlong long array_sum(const Array& arr) {\n    long long total = 0;\n    \n    #pragma omp parallel for reduction(+:total) schedule(static)\n    for (size_t i = 0; i < arr.size(); ++i) {\n        total += arr[i];\n    }\n    \n    return total;\n}",
        "framework": "OpenMP"
      }
    },
    {
      "metadata": {
        "task_type": "matrix_multiply",
        "hardware": {
          "cpus": [
            {
              "cores": 20,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <omp.h>\n\nvoid matrix_multiply(const Matrix& A, Matrix& result) {\n    int rows = A.size();\n    int cols = A[0].size();\n\n    #pragma omp parallel for collapse(2) schedule(static)\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < rows; ++j) {\n            long long sum = 0;\n            for (int k = 0; k < cols; ++k) {\n                sum += static_cast<long long>(A[i][k]) * A[j][k];\n            }\n            result[i][j] = static_cast<int>(sum);\n        }\n    }\n}",
        "framework": "OpenMP"
      }
    },
    {
      "metadata": {
        "task_type": "graph_bfs",
        "hardware": {
          "cpus": [
            {
              "cores": 20,
              "threads": 16,
              "frequency": "3.6 GHz",
              "available": "True"
            }
          ],
          "gpu": {
            "cuda_cores": 10496,
            "memory": {
              "size": "24 GB",
              "type": "GDDR6X"
            },
            "available": "True"
          }
        },
        "code": "#include <vector>\n#include <queue>\n#include <limits.h>\n#include <omp.h>\n\nvoid bfs(const Graph& graph, int start, std::vector<int> & result) {\n    const int numVertices = graph.numVertices;\n    result.assign(numVertices, -1);\n    \n    std::vector<int> frontier(1, start);\n    result[start] = 0;\n    \n    #pragma omp parallel\n    {\n        std::vector<int> local_frontier;\n        #pragma omp single\n        {\n            while (!frontier.empty()) {\n                #pragma omp for\n                for (int i = 0; i < frontier.size(); ++i) {\n                    int u = frontier[i];\n                    for (int j = graph.offset[u]; j < graph.offset[u + 1]; ++j) {\n                        int v = graph.edges[j];\n                        if (result[v] == -1) {\n                            // Only one thread can update a particular node\n                            #pragma omp atomic capture\n                            {\n                                if (result[v] == -1)\n                                    result[v] = result[u] + 1;\n                            }\n                            if (result[v] != -1)\n                                local_frontier.push_back(v);\n                        }\n                    }\n                }\n\n                frontier.swap(local_frontier);\n                local_frontier.clear();\n            }\n        }\n    }\n}",
        "framework": "OpenMP"
      }
    }
  ]
}